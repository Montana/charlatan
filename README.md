# Charlatan

[![Circle CI](https://circleci.com/gh/percolate/charlatan.svg?style=svg)](https://circleci.com/gh/percolate/charlatan)
[![codecov.io](https://codecov.io/github/percolate/charlatan/coverage.svg?branch=master)](https://codecov.io/github/percolate/charlatan?branch=master)

Percolate's Go Interface Mocking Tool.

## Install

It's go-gettable

```
$ go get github.com/percolate/charlatan
```

## Usage

Usage of charlatan:

```
        charlatan [options] <interface>
        charlatan -h | --help
```

Options:

```
  -dir string
        input package directory [default: current package directory]
  -file value
        name of input file, may be repeated, ignored if -dir is present
  -output string
        output file path [default: ./charlatan.go]
  -package string
        output package name [default: "<current package>"]
```

## How-to

Charlatan mocks can be created at the command line:

```
$ charlatan -output=./contexttest/charlatancontext.go -file=/usr/local/go/src/context/context.go -package=contexttest Context
```

or as a `go:generate` directive:

```
//go:generate charlatan -output=./contexttest/charlatancontext.go -file=/usr/local/go/src/context/context.go -package=contexttest Context
```

The resulting charlatan file:

```Go
// Code generated by "charlatan -output=./contexttest/charlatancontext.go -file=/usr/local/go/src/context/context.go -package=contexttest Context"; DO NOT EDIT.

package contexttest

import "time"

////////////////////////////////
// This is a mock for Context //
////////////////////////////////
type ValueInvocation struct {
        Parameters struct {
                Key interface{}
        }
        Results struct {
                Ret0 interface{}
        }
}

...

type FakeContext struct {
        DeadlineHook func() (deadline time.Time, ok bool)
        DoneHook     func() (ret0 <-chan struct{})
        ErrHook      func() (ret0 error)
        ValueHook    func(key interface{}) (ret0 interface{})

        DeadlineCalls []*DeadlineInvocation
        DoneCalls     []*DoneInvocation
        ErrCalls      []*ErrInvocation
        ValueCalls    []*ValueInvocation
}

func (a *FakeContext) Value(key interface{}) (ret0 interface{}) {
        invocation := new(ValueInvocation)

        invocation.Parameters.Key = key

        ret0 = a.ValueHook(key)

        invocation.Results.Ret0 = ret0

        a.ValueCalls = append(a.ValueCalls, invocation)

        return ret0
}
...
```

In tests, a `FakeContext` can be used anywhere a `Context` is required
since it implements the interface. Each `FakeContext` can be instantiated
with hook function fields. This structure makes it easy to control the
behavior of the mocked interface, while also allowing
inspection of method calls.

```Go
func CheckContext(c *Context) bool {
        return c.Value("PKey")
}

func TestCheckContext(t *testing.T) {
        pkey := "PKey"
        pval := true
        context := &contexttest.FakeContext{
                ValueHook: func(key interface{}) (ret0 interface{}) {
                        return pval
                },
        }
        p := CheckContext(context)

        valueCallCount := len(context.ValueCalls)
        if valueCallCount != 1 {
                t.Errorf("Value was called %d times", valueCallCount)
        }
        invocation := context.ValueCalls[0]
        if invocation.Parameters.Key != pkey {
                t.Errorf("Value was called with %s, expected %s", invocation.Parameters.Key, pkey)
        }
        if invocation.Results.Ret0 != pval {
                t.Errorf("Value returned %s, expected %s", invocation.Results.Ret0, pval)
        }
        if p != pval {
                t.Errorf("CheckContext returned %s, expected %s", p, pval)
        }
}
```
