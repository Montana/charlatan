# Charlatan

[![Circle CI](https://circleci.com/gh/percolate/charlatan.svg?style=svg)](https://circleci.com/gh/percolate/charlatan)
[![codecov.io](https://codecov.io/github/percolate/charlatan/coverage.svg?branch=master)](https://codecov.io/github/percolate/charlatan?branch=master)

Percolate's Go Interface Mocking Tool.


## Install

It's go-gettable
```
$ go get github.com/percolate/charlatan
```

## Usage

Usage of charlatan:
```
        charlatan [flags] -interfaces T
        charlatan [flags] -interfaces T [file]
```

Flags:
```
  -interfaces string
        comma-separated list of interface names; must be set
  -output string
        output file name; default srcdir/charlatan.go
  -packagename string
        output file package name; default to "<enclosingpackage>test"
```

## How-to

Charlatan mocks can be created at the command line:
```
$ charlatan -interfaces=Context -output=./charlatancontext.go /usr/local/go/src/context/context.go
```

or as a `go:generate` directive:
```
//go:generate charlatan -interfaces=Context -output=./contexttest/charlatancontext.go /usr/local/go/src/context/context.go
```

The resulting charlatan file:
```Go
// Code generated by "charlatan -interfaces=Context -output=./contexttest/charlatancontext.go /usr/local/go/src/context/context.go"; DO NOT EDIT.

package contexttest

import "time"

////////////////////////////////
// This is a mock for Context //
////////////////////////////////
type ValueInvocation struct {
	Parameters struct {
		Key interface{}
	}
	Results struct {
		Ret0 interface{}
	}
}

...

type FakeContext struct {
	DeadlineHook func() (deadline time.Time, ok bool)
	DoneHook     func() (ret0 <-chan struct{})
	ErrHook      func() (ret0 error)
	ValueHook    func(key interface{}) (ret0 interface{})

	DeadlineCalls []*DeadlineInvocation
	DoneCalls     []*DoneInvocation
	ErrCalls      []*ErrInvocation
	ValueCalls    []*ValueInvocation
}

func (a *FakeContext) Value(key interface{}) (ret0 interface{}) {
	invocation := new(ValueInvocation)

	invocation.Parameters.Key = key

	ret0 = a.ValueHook(key)

	invocation.Results.Ret0 = ret0

	a.ValueCalls = append(a.ValueCalls, invocation)

	return ret0
}
...
```

In tests, a `FakeContext` can be used anywhere a `Context` is required since it implements the interface. Each `FakeContext` can be instantiated with hook function fields. This structure makes it easy to control the behavior of the mocked interface, while also allowing inspection method calls.

```Go
func CheckContext(c *Context) bool {
    return c.Value("PKey")
}

func TestCheckContext(t *testing.T) {
    pkey := "PKey"
    pval := true
    context := &contexttest.FakeContext{
        ValueHook: func(key interface{}) (ret0 interface{}) {
            return pval
        },
    }
    p := CheckContext(context)

    valueCallCount := len(context.ValueCalls)
    if valueCallCount != 1 {
        t.Errorf("Value was called %d times", valueCallCount)
    }
    invocation := context.ValueCalls[0]
    if invocation.Parameters.Key != pkey {
        t.Errorf("Value was called with %s, expected %s", invocation.Parameters.Key, pkey)
    }
    if invocation.Results.Ret0 != pval {
        t.Errorf("Value returned %s, expected %s", invocation.Results.Ret0, pval)
    }
    if p != pval {
        t.Errorf("CheckContext returned %s, expected %s", p, pval)
    }
}
```
