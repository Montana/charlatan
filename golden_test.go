package main

import (
	"testing"
	"strings"
	"github.com/stretchr/testify/assert"
)

type Golden struct {
	name string
	input string
	output string
}

var golden = []Golden{
	{"Voider", void_in, void_out},
	{"Namedvaluer", namedvalues_in, namedvalues_out},
	{"Multireturner", multireturn_in, multireturn_out},
	{"Variadic", variadic_in, variadic_out},
	{"Pointer", pointer_in, pointer_out},
	{"Interfacer", interface_in, interface_out},
	{"Structer", struct_in, struct_out},
	{"Embedder", embed_in, embed_out},
	{"Qualifier", qualified_in, qualified_out},
}

const void_in = `type Voider interface {
	VoidMethod()
}`

const void_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type VoidMethodInvocation struct {
}

type FakeVoider struct {
	VoidMethodHook func()

	VoidMethodCalls []*VoidMethodInvocation
}

func (_a *FakeVoider) VoidMethod() {
	invocation := new(VoidMethodInvocation)

	_a.VoidMethodHook()

	_a.VoidMethodCalls = append(_a.VoidMethodCalls, invocation)

	return
}
`

const namedvalues_in = `type Namedvaluer interface {
	ManyNamed(a, b, c, d string, f, g, h int) (ret bool)
	Named(a int, b string) (ret bool)
}`

const namedvalues_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type ManyNamedInvocation struct {
	Parameters struct {
		A string
		B string
		C string
		D string
		F int
		G int
		H int
	}
	Results struct {
		Ret bool
	}
}

type NamedInvocation struct {
	Parameters struct {
		A int
		B string
	}
	Results struct {
		Ret bool
	}
}

type FakeNamedvaluer struct {
	ManyNamedHook func(a string, b string, c string, d string, f int, g int, h int) (ret bool)
	NamedHook     func(a int, b string) (ret bool)

	ManyNamedCalls []*ManyNamedInvocation
	NamedCalls     []*NamedInvocation
}

func (_a *FakeNamedvaluer) ManyNamed(a string, b string, c string, d string, f int, g int, h int) (ret bool) {
	invocation := new(ManyNamedInvocation)

	invocation.Parameters.A = a
	invocation.Parameters.B = b
	invocation.Parameters.C = c
	invocation.Parameters.D = d
	invocation.Parameters.F = f
	invocation.Parameters.G = g
	invocation.Parameters.H = h

	ret = _a.ManyNamedHook(a, b, c, d, f, g, h)

	invocation.Results.Ret = ret

	_a.ManyNamedCalls = append(_a.ManyNamedCalls, invocation)

	return ret
}

func (_a *FakeNamedvaluer) Named(a int, b string) (ret bool) {
	invocation := new(NamedInvocation)

	invocation.Parameters.A = a
	invocation.Parameters.B = b

	ret = _a.NamedHook(a, b)

	invocation.Results.Ret = ret

	_a.NamedCalls = append(_a.NamedCalls, invocation)

	return ret
}
`

const multireturn_in = `type Multireturner interface {
	MultiReturn() (string, int)
	NamedReturn() (a, b, c, d int)
}`

const multireturn_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type MultiReturnInvocation struct {
	Results struct {
		Ret0 string
		Ret1 int
	}
}

type NamedReturnInvocation struct {
	Results struct {
		A int
		B int
		C int
		D int
	}
}

type FakeMultireturner struct {
	MultiReturnHook func() (ret0 string, ret1 int)
	NamedReturnHook func() (a int, b int, c int, d int)

	MultiReturnCalls []*MultiReturnInvocation
	NamedReturnCalls []*NamedReturnInvocation
}

func (_a *FakeMultireturner) MultiReturn() (ret0 string, ret1 int) {
	invocation := new(MultiReturnInvocation)

	ret0, ret1 = _a.MultiReturnHook()

	invocation.Results.Ret0 = ret0
	invocation.Results.Ret1 = ret1

	_a.MultiReturnCalls = append(_a.MultiReturnCalls, invocation)

	return ret0, ret1
}

func (_a *FakeMultireturner) NamedReturn() (a int, b int, c int, d int) {
	invocation := new(NamedReturnInvocation)

	a, b, c, d = _a.NamedReturnHook()

	invocation.Results.A = a
	invocation.Results.B = b
	invocation.Results.C = c
	invocation.Results.D = d

	_a.NamedReturnCalls = append(_a.NamedReturnCalls, invocation)

	return a, b, c, d
}
`

const variadic_in = `type Variadic interface {
	SingleVariadic(a... string)
	MixedVariadic(a, b, c int, d... string)
}`

const variadic_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type SingleVariadicInvocation struct {
	Parameters struct {
		A []string
	}
}

type MixedVariadicInvocation struct {
	Parameters struct {
		A int
		B int
		C int
		D []string
	}
}

type FakeVariadic struct {
	SingleVariadicHook func(a ...string)
	MixedVariadicHook  func(a int, b int, c int, d ...string)

	SingleVariadicCalls []*SingleVariadicInvocation
	MixedVariadicCalls  []*MixedVariadicInvocation
}

func (_a *FakeVariadic) SingleVariadic(a ...string) {
	invocation := new(SingleVariadicInvocation)

	invocation.Parameters.A = a

	_a.SingleVariadicHook(a...)

	_a.SingleVariadicCalls = append(_a.SingleVariadicCalls, invocation)

	return
}

func (_a *FakeVariadic) MixedVariadic(a int, b int, c int, d ...string) {
	invocation := new(MixedVariadicInvocation)

	invocation.Parameters.A = a
	invocation.Parameters.B = b
	invocation.Parameters.C = c
	invocation.Parameters.D = d

	_a.MixedVariadicHook(a, b, c, d...)

	_a.MixedVariadicCalls = append(_a.MixedVariadicCalls, invocation)

	return
}
`

const pointer_in = `type Pointer interface {
	Point(*string) *int
}`

const pointer_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type PointInvocation struct {
	Parameters struct {
		Arg0 *string
	}
	Results struct {
		Ret0 *int
	}
}

type FakePointer struct {
	PointHook func(arg0 *string) (ret0 *int)

	PointCalls []*PointInvocation
}

func (_a *FakePointer) Point(arg0 *string) (ret0 *int) {
	invocation := new(PointInvocation)

	invocation.Parameters.Arg0 = arg0

	ret0 = _a.PointHook(arg0)

	invocation.Results.Ret0 = ret0

	_a.PointCalls = append(_a.PointCalls, invocation)

	return ret0
}
`

const interface_in = `type Interfacer interface {
	Interface(interface{}) interface{}
	NamedInterface(a interface{}) (z interface{})
}`

const interface_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type InterfaceInvocation struct {
	Parameters struct {
		Arg0 interface{}
	}
	Results struct {
		Ret0 interface{}
	}
}

type NamedInterfaceInvocation struct {
	Parameters struct {
		A interface{}
	}
	Results struct {
		Z interface{}
	}
}

type FakeInterfacer struct {
	InterfaceHook      func(arg0 interface{}) (ret0 interface{})
	NamedInterfaceHook func(a interface{}) (z interface{})

	InterfaceCalls      []*InterfaceInvocation
	NamedInterfaceCalls []*NamedInterfaceInvocation
}

func (_a *FakeInterfacer) Interface(arg0 interface{}) (ret0 interface{}) {
	invocation := new(InterfaceInvocation)

	invocation.Parameters.Arg0 = arg0

	ret0 = _a.InterfaceHook(arg0)

	invocation.Results.Ret0 = ret0

	_a.InterfaceCalls = append(_a.InterfaceCalls, invocation)

	return ret0
}

func (_a *FakeInterfacer) NamedInterface(a interface{}) (z interface{}) {
	invocation := new(NamedInterfaceInvocation)

	invocation.Parameters.A = a

	z = _a.NamedInterfaceHook(a)

	invocation.Results.Z = z

	_a.NamedInterfaceCalls = append(_a.NamedInterfaceCalls, invocation)

	return z
}
`

const struct_in = `type Structer interface {
	Struct(struct{}) struct{}
	NamedStruct(a struct{}) (z struct{})
}`

const struct_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type StructInvocation struct {
	Parameters struct {
		Arg0 struct{}
	}
	Results struct {
		Ret0 struct{}
	}
}

type NamedStructInvocation struct {
	Parameters struct {
		A struct{}
	}
	Results struct {
		Z struct{}
	}
}

type FakeStructer struct {
	StructHook      func(arg0 struct{}) (ret0 struct{})
	NamedStructHook func(a struct{}) (z struct{})

	StructCalls      []*StructInvocation
	NamedStructCalls []*NamedStructInvocation
}

func (_a *FakeStructer) Struct(arg0 struct{}) (ret0 struct{}) {
	invocation := new(StructInvocation)

	invocation.Parameters.Arg0 = arg0

	ret0 = _a.StructHook(arg0)

	invocation.Results.Ret0 = ret0

	_a.StructCalls = append(_a.StructCalls, invocation)

	return ret0
}

func (_a *FakeStructer) NamedStruct(a struct{}) (z struct{}) {
	invocation := new(NamedStructInvocation)

	invocation.Parameters.A = a

	z = _a.NamedStructHook(a)

	invocation.Results.Z = z

	_a.NamedStructCalls = append(_a.NamedStructCalls, invocation)

	return z
}
`

const embed_in = `type Embeddable interface {
	Embed()
}

type Embedder interface {
	Embeddable
	Other()
}`

// Right now, we just skip over embedded interfaces, but maybe
// someday we can parse the embedded interface's methods and
// add them to the Fake
const embed_out = `// generated by "charlatan "; DO NOT EDIT.

package test

type OtherInvocation struct {
}

type FakeEmbedder struct {
	OtherHook func()

	OtherCalls []*OtherInvocation
}

func (_a *FakeEmbedder) Other() {
	invocation := new(OtherInvocation)

	_a.OtherHook()

	_a.OtherCalls = append(_a.OtherCalls, invocation)

	return
}
`

const qualified_in = `import "fmt"

type Qualifier interface {
	Qualify(fmt.Scanner) *fmt.Scanner
	NamedQualify(a, b, c fmt.Scanner) (d *fmt.Scanner)
}`

const qualified_out = `// generated by "charlatan "; DO NOT EDIT.

package test

import "fmt"

type QualifyInvocation struct {
	Parameters struct {
		Arg0 fmt.Scanner
	}
	Results struct {
		Ret0 *fmt.Scanner
	}
}

type NamedQualifyInvocation struct {
	Parameters struct {
		A fmt.Scanner
		B fmt.Scanner
		C fmt.Scanner
	}
	Results struct {
		D *fmt.Scanner
	}
}

type FakeQualifier struct {
	QualifyHook      func(arg0 fmt.Scanner) (ret0 *fmt.Scanner)
	NamedQualifyHook func(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) (d *fmt.Scanner)

	QualifyCalls      []*QualifyInvocation
	NamedQualifyCalls []*NamedQualifyInvocation
}

func (_a *FakeQualifier) Qualify(arg0 fmt.Scanner) (ret0 *fmt.Scanner) {
	invocation := new(QualifyInvocation)

	invocation.Parameters.Arg0 = arg0

	ret0 = _a.QualifyHook(arg0)

	invocation.Results.Ret0 = ret0

	_a.QualifyCalls = append(_a.QualifyCalls, invocation)

	return ret0
}

func (_a *FakeQualifier) NamedQualify(a fmt.Scanner, b fmt.Scanner, c fmt.Scanner) (d *fmt.Scanner) {
	invocation := new(NamedQualifyInvocation)

	invocation.Parameters.A = a
	invocation.Parameters.B = b
	invocation.Parameters.C = c

	d = _a.NamedQualifyHook(a, b, c)

	invocation.Results.D = d

	_a.NamedQualifyCalls = append(_a.NamedQualifyCalls, invocation)

	return d
}
`

func TestGolden(t *testing.T) {
	for _, test := range golden {
		var g Generator
		input := "package test\n" + test.input
		file := strings.ToLower(test.name) + ".go"
		g.interfaces = []string{test.name}
		g.parsePackage(".", []string{file}, input)
		got := string(g.generate())

		assert.Equal(t, test.output, got)
	}
}
