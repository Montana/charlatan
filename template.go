package main

import (
	"io"
	"text/template"
)

const charlatanTemplate = `// generated by "{{.CommandLine}}".  DO NOT EDIT.

package {{.PackageName}}

import (
	"reflect"
	"testing"
{{range .Imports}} "{{.}}"
{{end}}
)
{{range .Interfaces}}{{range .Methods}}
// {{.Name}}Invocation represents a single call of Fake{{.InterfaceName}}.{{.Name}}
type {{.Name}}Invocation struct {
{{if .Params}}	Parameters struct {
{{range .Params}}	{{.StructDef}}
{{end}}
	}{{end}}
{{if .Results}}	Results struct {
{{range .Results}}	{{.StructDef}}
{{end}}
	}{{end}}
}
{{end}}

/*
Fake{{.Name}} is a mock implementation of {{.Name}} for testing.
{{if .Methods}}{{with $m := index .Methods 0}}Use it in your tests as in this example:

	package example

	func TestWith{{$m.InterfaceName}}(t *testing.T) {
		f := &{{$.PackageName}}.Fake{{$m.InterfaceName}}{
			{{$m.Name}}Hook: func({{$m.FormatParamsDeclaration}}) ({{$m.FormatResultsDeclaration}}) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			}
		}

		// test code goes here ...

		// asset state of Fake{{.Name}} ...
		f.Assert{{$m.Name}}CalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a painc if any
unexpected calls are made to Fake{{.Name}}.
{{end}}{{end}}*/
type Fake{{.Name}} struct {
{{range .Methods}} {{.Name}}Hook func({{.FormatParamsDeclaration}}) ({{.FormatResultsDeclaration}})
{{end}}
{{range .Methods}} {{.Name}}Calls []*{{.Name}}Invocation
{{end}}}

{{range .Methods}}
func (f *Fake{{.InterfaceName}}) {{.Name}}({{.FormatParamsDeclaration}}) ({{.FormatResultsDeclaration}}) {
	invocation := new({{.Name}}Invocation)

{{if .Params}}{{range .Params}} invocation.Parameters.{{.CapitalName}} = {{.Name}}
{{end}}{{end}}
{{if .Results}} {{.FormatResultsCall}} = f.{{.Name}}Hook({{.FormatParamsCall}})
{{else}} f.{{.Name}}Hook({{.FormatParamsCall}})
{{end}}
{{if .Results}}{{range .Results}}invocation.Results.{{.CapitalName}} = {{.Name}}
{{end}}{{end}}
	f.{{.Name}}Calls = append(f.{{.Name}}Calls, invocation)

	return
}

// {{.Name}}Called returns true if Fake{{.InterfaceName}}.{{.Name}} was called
func (f *Fake{{.InterfaceName}}) {{.Name}}Called() bool {
	return len(f.{{.Name}}Calls) != 0
}

// Assert{{.Name}}Called calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}Called(t *testing.T) {
	t.Helper()
	if len(f.{{.Name}}Calls) == 0 {
		t.Error("Fake{{.InterfaceName}}.{{.Name}} not called, expected at least one")
	}
}

// {{.Name}}NotCalled returns true if Fake{{.InterfaceName}}.{{.Name}} was not called
func (f *Fake{{.InterfaceName}}) {{.Name}}NotCalled() bool {
	return len(f.{{.Name}}Calls) == 0
}

// Assert{{.Name}}NotCalled calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was called
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}NotCalled(t *testing.T) {
	t.Helper()
	if len(f.{{.Name}}Calls) != 0 {
		t.Error("Fake{{.InterfaceName}}.{{.Name}} called, expected none")
	}
}

// {{.Name}}CalledOnce returns true if Fake{{.InterfaceName}}.{{.Name}} was called exactly once
func (f *Fake{{.InterfaceName}}) {{.Name}}CalledOnce() bool {
	return len(f.{{.Name}}Calls) == 1
}

// Assert{{.Name}}CalledOnce calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called exactly once
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}CalledOnce(t *testing.T) {
	t.Helper()
	if len(f.{{.Name}}Calls) != 1 {
		t.Error("Fake{{.InterfaceName}}.{{.Name}} called %d times, expected 1", len(f.{{.Name}}Calls))
	}
}

// {{.Name}}CalledN returns true if Fake{{.InterfaceName}}.{{.Name}} was called at least n times
func (f *Fake{{.InterfaceName}}) {{.Name}}CalledN(n int) bool {
	return len(f.{{.Name}}Calls) >= n
}

// Assert{{.Name}}CalledN calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was called less than n times
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}CalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.{{.Name}}Calls) < n {
		t.Errorf("Fake{{.InterfaceName}}.{{.Name}} called %d times, expected >= %d", len(f.{{.Name}}Calls), n)
	}
}

{{if .Params}}// {{.Name}}CalledWith returns true if Fake{{.InterfaceName}}.{{.Name}} was called with the given values
func (f *Fake{{.InterfaceName}}) {{.Name}}CalledWith({{.FormatParamsDeclaration}}) bool {
	var found bool
	for _, call := range f.{{.Name}}Calls {
		if {{range $i, $p := .Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			found = true
			break
		}
	}

	return found
}

// Assert{{.Name}}CalledWith calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called with the given values
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}CalledWith(t *testing.T, {{.FormatParamsDeclaration}}) {
	t.Helper()
	var found bool
	for _, call := range f.{{.Name}}Calls {
		if {{range $i, $p := .Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			found = true
			break
		}
	}

	if !found {
		t.Error("Fake{{.InterfaceName}}.{{.Name}} not called with expected parameters")
	}
}

// {{.Name}}CalledOnceWith returns true if Fake{{.InterfaceName}}.{{.Name}} was called exactly once with the given values
func (f *Fake{{.InterfaceName}}) {{.Name}}CalledOnceWith({{.FormatParamsDeclaration}}) bool {
	var count int
	for _, call := range f.{{.Name}}Calls {
		if {{range $i, $p := .Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			count++
		}
	}

	return count == 1
}

// Assert{{.Name}}CalledOnceWith calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called exactly once with the given values
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}OnceCalledWith(t *testing.T, {{.FormatParamsDeclaration}}) {
	t.Helper()
	var count int
	for _, call := range f.{{.Name}}Calls {
		if {{range $i, $p := .Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			count++
		}
	}

	if count != 1 {
		t.Errorf("Fake{{.InterfaceName}}.{{.Name}} called %d times with expected parameters, expected one", count)
	}
}

// {{.Name}}ResultsForCall returns the result values for the first call to Fake{{.InterfaceName}}.{{.Name}} with the given values
func (f *Fake{{.InterfaceName}}) {{.Name}}ResultsForCall({{.FormatParamsDeclaration}}) ({{.FormatResultsDeclaration}}, found bool) {
	for _, call := range f.{{.Name}}Calls {
		if {{range $i, $p := .Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			{{range .Results}}{{.Name}} = call.Results.{{.CapitalName}}
			{{end}}
			found = true
			break
		}
	}

	return
}
{{end}}
{{end}}
{{end}}
`

var (
	charlatanTempl  = template.Must(template.New("charlatan").Parse(charlatanTemplate))
)

type Template struct {
	CommandLine string
	PackageName string
	Imports     []string
	Interfaces  []*InterfaceDeclaration
}

func (t *Template) Execute(w io.Writer) error {
	return charlatanTempl.Execute(w, t)
}
