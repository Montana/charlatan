package main

import (
	"bytes"
	"fmt"
	"go/format"
	"text/template"
)

const charlatanTemplate = `// generated by "{{.CommandLine}}".  DO NOT EDIT.

package {{.PackageName}}

import (
	"reflect"
	"testing"
{{range .Imports}} "{{.}}"
{{end}}
)
{{range .Interfaces}}{{range .Methods}}
// {{.Name}}Invocation represents a single call of Fake{{.InterfaceName}}.{{.Name}}
type {{.Name}}Invocation struct {
{{if .Params}}	Parameters struct {
{{range .Params}}	{{.StructDef}}
{{end}}
	}{{end}}
{{if .Results}}	Results struct {
{{range .Results}}	{{.StructDef}}
{{end}}
	}{{end}}
}
{{end}}

/*
Fake{{.Name}} is a mock implementation of {{.Name}} for testing.
{{if .Methods}}{{with $m := index .Methods 0}}Use it in your tests as in this example:

	package example

	func TestWith{{$m.InterfaceName}}(t *testing.T) {
		f := &{{$.PackageName}}.Fake{{$m.InterfaceName}}{
			{{$m.Name}}Hook: func({{$m.FormatParamsDeclaration}}) ({{$m.FormatResultsDeclaration}}) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			}
		}

		// test code goes here ...

		// asset state of Fake{{.Name}} ...
		f.Assert{{$m.Name}}CalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a painc if any
unexpected calls are made to Fake{{.Name}}.
{{end}}{{end}}*/
type Fake{{.Name}} struct {
{{range .Methods}} {{.Name}}Hook func({{.FormatParamsDeclaration}}) ({{.FormatResultsDeclaration}})
{{end}}
{{range .Methods}} {{.Name}}Calls []*{{.Name}}Invocation
{{end}}}

{{range $m := .Methods}}
{{with $f := gensym}}func ({{$f}} *Fake{{$m.InterfaceName}}) {{$m.Name}}({{$m.FormatParamsDeclaration}}) ({{$m.FormatResultsDeclaration}}) {
	invocation := new({{$m.Name}}Invocation)

{{if $m.Params}}{{range $m.Params}} invocation.Parameters.{{.CapitalName}} = {{.Name}}
{{end}}{{end}}
{{if $m.Results}} {{$m.FormatResultsCall}} = {{$f}}.{{$m.Name}}Hook({{$m.FormatParamsCall}})
{{else}} {{$f}}.{{$m.Name}}Hook({{$m.FormatParamsCall}})
{{end}}
{{if $m.Results}}{{range $m.Results}}invocation.Results.{{.CapitalName}} = {{.Name}}
{{end}}{{end}}
	{{$f}}.{{$m.Name}}Calls = append({{$f}}.{{$m.Name}}Calls, invocation)

	return
}{{end}}

// {{.Name}}Called returns true if Fake{{.InterfaceName}}.{{.Name}} was called
func (f *Fake{{.InterfaceName}}) {{.Name}}Called() bool {
	return len(f.{{.Name}}Calls) != 0
}

// Assert{{.Name}}Called calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}Called(t *testing.T) {
	t.Helper()
	if len(f.{{.Name}}Calls) == 0 {
		t.Error("Fake{{.InterfaceName}}.{{.Name}} not called, expected at least one")
	}
}

// {{.Name}}NotCalled returns true if Fake{{.InterfaceName}}.{{.Name}} was not called
func (f *Fake{{.InterfaceName}}) {{.Name}}NotCalled() bool {
	return len(f.{{.Name}}Calls) == 0
}

// Assert{{.Name}}NotCalled calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was called
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}NotCalled(t *testing.T) {
	t.Helper()
	if len(f.{{.Name}}Calls) != 0 {
		t.Error("Fake{{.InterfaceName}}.{{.Name}} called, expected none")
	}
}

// {{.Name}}CalledOnce returns true if Fake{{.InterfaceName}}.{{.Name}} was called exactly once
func (f *Fake{{.InterfaceName}}) {{.Name}}CalledOnce() bool {
	return len(f.{{.Name}}Calls) == 1
}

// Assert{{.Name}}CalledOnce calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called exactly once
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}CalledOnce(t *testing.T) {
	t.Helper()
	if len(f.{{.Name}}Calls) != 1 {
		t.Errorf("Fake{{.InterfaceName}}.{{.Name}} called %d times, expected 1", len(f.{{.Name}}Calls))
	}
}

// {{.Name}}CalledN returns true if Fake{{.InterfaceName}}.{{.Name}} was called at least n times
func (f *Fake{{.InterfaceName}}) {{.Name}}CalledN(n int) bool {
	return len(f.{{.Name}}Calls) >= n
}

// Assert{{.Name}}CalledN calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was called less than n times
func (f *Fake{{.InterfaceName}}) Assert{{.Name}}CalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.{{.Name}}Calls) < n {
		t.Errorf("Fake{{.InterfaceName}}.{{.Name}} called %d times, expected >= %d", len(f.{{.Name}}Calls), n)
	}
}

{{if .Params}}// {{.Name}}CalledWith returns true if Fake{{.InterfaceName}}.{{.Name}} was called with the given values
{{with $f := gensym}}func ({{$f}} *Fake{{$m.InterfaceName}}) {{$m.Name}}CalledWith({{$m.FormatParamsDeclaration}}) bool {
	var found bool
	for _, call := range {{$f}}.{{$m.Name}}Calls {
		if {{range $i, $p := $m.Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			found = true
			break
		}
	}

	return found
}{{end}}

// Assert{{.Name}}CalledWith calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called with the given values
{{with $f := gensym}}func ({{$f}} *Fake{{$m.InterfaceName}}) Assert{{$m.Name}}CalledWith(t *testing.T, {{$m.FormatParamsDeclaration}}) {
	t.Helper()
	var found bool
	for _, call := range {{$f}}.{{$m.Name}}Calls {
		if {{range $i, $p := $m.Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			found = true
			break
		}
	}

	if !found {
		t.Error("Fake{{$m.InterfaceName}}.{{$m.Name}} not called with expected parameters")
	}
}{{end}}

// {{.Name}}CalledOnceWith returns true if Fake{{.InterfaceName}}.{{.Name}} was called exactly once with the given values
{{with $f := gensym}}func ({{$f}} *Fake{{$m.InterfaceName}}) {{$m.Name}}CalledOnceWith({{$m.FormatParamsDeclaration}}) bool {
	var count int
	for _, call := range {{$f}}.{{$m.Name}}Calls {
		if {{range $i, $p := $m.Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			count++
		}
	}

	return count == 1
}{{end}}

// Assert{{.Name}}CalledOnceWith calls t.Error if Fake{{.InterfaceName}}.{{.Name}} was not called exactly once with the given values
{{with $f := gensym}}func ({{$f}} *Fake{{$m.InterfaceName}}) Assert{{$m.Name}}OnceCalledWith(t *testing.T, {{$m.FormatParamsDeclaration}}) {
	t.Helper()
	var count int
	for _, call := range {{$f}}.{{$m.Name}}Calls {
		if {{range $i, $p := $m.Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			count++
		}
	}

	if count != 1 {
		t.Errorf("Fake{{$m.InterfaceName}}.{{$m.Name}} called %d times with expected parameters, expected one", count)
	}
}{{end}}

// {{.Name}}ResultsForCall returns the result values for the first call to Fake{{.InterfaceName}}.{{.Name}} with the given values
{{with $f := gensym}}func ({{$f}} *Fake{{$m.InterfaceName}}) {{$m.Name}}ResultsForCall({{$m.FormatParamsDeclaration}}) ({{$m.FormatResultsDeclaration}}, found bool) {
	for _, call := range {{$f}}.{{$m.Name}}Calls {
		if {{range $i, $p := $m.Params}}{{if $i}} && {{end}}reflect.DeepEqual(call.Parameters.{{$p.CapitalName}}, {{$p.Name}}){{end}} {
			{{range $m.Results}}{{.Name}} = call.Results.{{.CapitalName}}
			{{end}}found = true
			break
		}
	}

	return
}{{end}}
{{end}}
{{end}}
{{end}}
`

var (
	symGen         = SymbolGenerator{Prefix: "_f"}
	funky          = template.FuncMap{"gensym": func() string { return symGen.Next() }}
	charlatanTempl = template.Must(template.New("charlatan").Funcs(funky).Parse(charlatanTemplate))
)

type Template struct {
	CommandLine string
	PackageName string
	Imports     []string
	Interfaces  []*Interface
}

func (t *Template) Execute() ([]byte, error) {
	var buf bytes.Buffer
	if err := charlatanTempl.Execute(&buf, t); err != nil {
		return nil, err
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		// Should not happen except when developing this code.
		// The user can compile the output to see the error.
		return buf.Bytes(), fmt.Errorf("warning: internal error: invalid code generated: %s", err)
	}

	return src, nil
}
