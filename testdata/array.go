// generated by "charlatan -file=testdata/array_def.go -output=testdata/array.go Array".  DO NOT EDIT.

package main

import (
	"reflect"
	"testing"
)

// ArrayParameterInvocation represents a single call of FakeArray.ArrayParameter
type ArrayParameterInvocation struct {
	Parameters struct {
		Ident1 []string
	}
}

// ArrayReturnInvocation represents a single call of FakeArray.ArrayReturn
type ArrayReturnInvocation struct {
	Results struct {
		Ident2 []string
	}
}

/*
FakeArray is a mock implementation of Array for testing.
Use it in your tests as in this example:

	package example

	func TestWithArray(t *testing.T) {
		f := &main.FakeArray{
			ArrayParameterHook: func(ident1 []string) () {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeArrayParameter ...
		f.AssertArrayParameterCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a painc if any
unexpected calls are made to FakeArrayParameter.
*/
type FakeArray struct {
	ArrayParameterHook func([]string)
	ArrayReturnHook    func() []string

	ArrayParameterCalls []*ArrayParameterInvocation
	ArrayReturnCalls    []*ArrayReturnInvocation
}

// NewFakeArrayDefaultPanic returns an instance of FakeArray with all hooks configured to panic
func NewFakeArrayDefaultPanic() *FakeArray {
	return &FakeArray{
		ArrayParameterHook: func([]string) {
			panic("Unexpected call to Array.ArrayParameter")
			return
		},
		ArrayReturnHook: func() (ident2 []string) {
			panic("Unexpected call to Array.ArrayReturn")
			return
		},
	}
}

// NewFakeArrayDefaultFatal returns an instance of FakeArray with all hooks configured to call t.Fatal
func NewFakeArrayDefaultFatal(t *testing.T) *FakeArray {
	return &FakeArray{
		ArrayParameterHook: func([]string) {
			t.Fatal("Unexpected call to Array.ArrayParameter")
			return
		},
		ArrayReturnHook: func() (ident2 []string) {
			t.Fatal("Unexpected call to Array.ArrayReturn")
			return
		},
	}
}

// NewFakeArrayDefaultError returns an instance of FakeArray with all hooks configured to call t.Error
func NewFakeArrayDefaultError(t *testing.T) *FakeArray {
	return &FakeArray{
		ArrayParameterHook: func([]string) {
			t.Error("Unexpected call to Array.ArrayParameter")
			return
		},
		ArrayReturnHook: func() (ident2 []string) {
			t.Error("Unexpected call to Array.ArrayReturn")
			return
		},
	}
}

func (_f1 *FakeArray) ArrayParameter(ident1 []string) {
	invocation := new(ArrayParameterInvocation)

	invocation.Parameters.Ident1 = ident1

	_f1.ArrayParameterHook(ident1)

	_f1.ArrayParameterCalls = append(_f1.ArrayParameterCalls, invocation)

	return
}

// ArrayParameterCalled returns true if FakeArray.ArrayParameter was called
func (f *FakeArray) ArrayParameterCalled() bool {
	return len(f.ArrayParameterCalls) != 0
}

// AssertArrayParameterCalled calls t.Error if FakeArray.ArrayParameter was not called
func (f *FakeArray) AssertArrayParameterCalled(t *testing.T) {
	t.Helper()
	if len(f.ArrayParameterCalls) == 0 {
		t.Error("FakeArray.ArrayParameter not called, expected at least one")
	}
}

// ArrayParameterNotCalled returns true if FakeArray.ArrayParameter was not called
func (f *FakeArray) ArrayParameterNotCalled() bool {
	return len(f.ArrayParameterCalls) == 0
}

// AssertArrayParameterNotCalled calls t.Error if FakeArray.ArrayParameter was called
func (f *FakeArray) AssertArrayParameterNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ArrayParameterCalls) != 0 {
		t.Error("FakeArray.ArrayParameter called, expected none")
	}
}

// ArrayParameterCalledOnce returns true if FakeArray.ArrayParameter was called exactly once
func (f *FakeArray) ArrayParameterCalledOnce() bool {
	return len(f.ArrayParameterCalls) == 1
}

// AssertArrayParameterCalledOnce calls t.Error if FakeArray.ArrayParameter was not called exactly once
func (f *FakeArray) AssertArrayParameterCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ArrayParameterCalls) != 1 {
		t.Errorf("FakeArray.ArrayParameter called %d times, expected 1", len(f.ArrayParameterCalls))
	}
}

// ArrayParameterCalledN returns true if FakeArray.ArrayParameter was called at least n times
func (f *FakeArray) ArrayParameterCalledN(n int) bool {
	return len(f.ArrayParameterCalls) >= n
}

// AssertArrayParameterCalledN calls t.Error if FakeArray.ArrayParameter was called less than n times
func (f *FakeArray) AssertArrayParameterCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ArrayParameterCalls) < n {
		t.Errorf("FakeArray.ArrayParameter called %d times, expected >= %d", len(f.ArrayParameterCalls), n)
	}
}

// ArrayParameterCalledWith returns true if FakeArray.ArrayParameter was called with the given values
func (_f2 *FakeArray) ArrayParameterCalledWith(ident1 []string) (found bool) {
	for _, call := range _f2.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertArrayParameterCalledWith calls t.Error if FakeArray.ArrayParameter was not called with the given values
func (_f3 *FakeArray) AssertArrayParameterCalledWith(t *testing.T, ident1 []string) {
	t.Helper()
	var found bool
	for _, call := range _f3.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeArray.ArrayParameter not called with expected parameters")
	}
}

// ArrayParameterCalledOnceWith returns true if FakeArray.ArrayParameter was called exactly once with the given values
func (_f4 *FakeArray) ArrayParameterCalledOnceWith(ident1 []string) bool {
	var count int
	for _, call := range _f4.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertArrayParameterCalledOnceWith calls t.Error if FakeArray.ArrayParameter was not called exactly once with the given values
func (_f5 *FakeArray) AssertArrayParameterCalledOnceWith(t *testing.T, ident1 []string) {
	t.Helper()
	var count int
	for _, call := range _f5.ArrayParameterCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeArray.ArrayParameter called %d times with expected parameters, expected one", count)
	}
}

func (_f6 *FakeArray) ArrayReturn() (ident2 []string) {
	invocation := new(ArrayReturnInvocation)

	ident2 = _f6.ArrayReturnHook()

	invocation.Results.Ident2 = ident2

	_f6.ArrayReturnCalls = append(_f6.ArrayReturnCalls, invocation)

	return
}

// ArrayReturnCalled returns true if FakeArray.ArrayReturn was called
func (f *FakeArray) ArrayReturnCalled() bool {
	return len(f.ArrayReturnCalls) != 0
}

// AssertArrayReturnCalled calls t.Error if FakeArray.ArrayReturn was not called
func (f *FakeArray) AssertArrayReturnCalled(t *testing.T) {
	t.Helper()
	if len(f.ArrayReturnCalls) == 0 {
		t.Error("FakeArray.ArrayReturn not called, expected at least one")
	}
}

// ArrayReturnNotCalled returns true if FakeArray.ArrayReturn was not called
func (f *FakeArray) ArrayReturnNotCalled() bool {
	return len(f.ArrayReturnCalls) == 0
}

// AssertArrayReturnNotCalled calls t.Error if FakeArray.ArrayReturn was called
func (f *FakeArray) AssertArrayReturnNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ArrayReturnCalls) != 0 {
		t.Error("FakeArray.ArrayReturn called, expected none")
	}
}

// ArrayReturnCalledOnce returns true if FakeArray.ArrayReturn was called exactly once
func (f *FakeArray) ArrayReturnCalledOnce() bool {
	return len(f.ArrayReturnCalls) == 1
}

// AssertArrayReturnCalledOnce calls t.Error if FakeArray.ArrayReturn was not called exactly once
func (f *FakeArray) AssertArrayReturnCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ArrayReturnCalls) != 1 {
		t.Errorf("FakeArray.ArrayReturn called %d times, expected 1", len(f.ArrayReturnCalls))
	}
}

// ArrayReturnCalledN returns true if FakeArray.ArrayReturn was called at least n times
func (f *FakeArray) ArrayReturnCalledN(n int) bool {
	return len(f.ArrayReturnCalls) >= n
}

// AssertArrayReturnCalledN calls t.Error if FakeArray.ArrayReturn was called less than n times
func (f *FakeArray) AssertArrayReturnCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ArrayReturnCalls) < n {
		t.Errorf("FakeArray.ArrayReturn called %d times, expected >= %d", len(f.ArrayReturnCalls), n)
	}
}
