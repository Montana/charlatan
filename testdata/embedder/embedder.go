// generated by "charlatan -dir=testdata/embedder -output=testdata/embedder/embedder.go Embedder".  DO NOT EDIT.

package main

import (
	"reflect"
	"testing"
)

// StringInvocation represents a single call of FakeEmbedder.String
type StringInvocation struct {
	Results struct {
		Ident5 string
	}
}

// EmbedInvocation represents a single call of FakeEmbedder.Embed
type EmbedInvocation struct {
	Parameters struct {
		Ident8 string
	}
	Results struct {
		Ident9 string
	}
}

// OtherInvocation represents a single call of FakeEmbedder.Other
type OtherInvocation struct {
	Parameters struct {
		Ident6 string
	}
	Results struct {
		Ident7 string
	}
}

/*
FakeEmbedder is a mock implementation of Embedder for testing.
Use it in your tests as in this example:

	package example

	func TestWithEmbedder(t *testing.T) {
		f := &main.FakeEmbedder{
			StringHook: func() (ident5 string) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeString ...
		f.AssertStringCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeString.
*/
type FakeEmbedder struct {
	StringHook func() string
	EmbedHook  func(string) string
	OtherHook  func(string) string

	StringCalls []*StringInvocation
	EmbedCalls  []*EmbedInvocation
	OtherCalls  []*OtherInvocation
}

// NewFakeEmbedderDefaultPanic returns an instance of FakeEmbedder with all hooks configured to panic
func NewFakeEmbedderDefaultPanic() *FakeEmbedder {
	return &FakeEmbedder{
		StringHook: func() (ident5 string) {
			panic("Unexpected call to Embedder.String")
		},
		EmbedHook: func(string) (ident9 string) {
			panic("Unexpected call to Embedder.Embed")
		},
		OtherHook: func(string) (ident7 string) {
			panic("Unexpected call to Embedder.Other")
		},
	}
}

// NewFakeEmbedderDefaultFatal returns an instance of FakeEmbedder with all hooks configured to call t.Fatal
func NewFakeEmbedderDefaultFatal(t *testing.T) *FakeEmbedder {
	return &FakeEmbedder{
		StringHook: func() (ident5 string) {
			t.Fatal("Unexpected call to Embedder.String")
			return
		},
		EmbedHook: func(string) (ident9 string) {
			t.Fatal("Unexpected call to Embedder.Embed")
			return
		},
		OtherHook: func(string) (ident7 string) {
			t.Fatal("Unexpected call to Embedder.Other")
			return
		},
	}
}

// NewFakeEmbedderDefaultError returns an instance of FakeEmbedder with all hooks configured to call t.Error
func NewFakeEmbedderDefaultError(t *testing.T) *FakeEmbedder {
	return &FakeEmbedder{
		StringHook: func() (ident5 string) {
			t.Error("Unexpected call to Embedder.String")
			return
		},
		EmbedHook: func(string) (ident9 string) {
			t.Error("Unexpected call to Embedder.Embed")
			return
		},
		OtherHook: func(string) (ident7 string) {
			t.Error("Unexpected call to Embedder.Other")
			return
		},
	}
}

func (_f1 *FakeEmbedder) String() (ident5 string) {
	invocation := new(StringInvocation)

	ident5 = _f1.StringHook()

	invocation.Results.Ident5 = ident5

	_f1.StringCalls = append(_f1.StringCalls, invocation)

	return
}

// StringCalled returns true if FakeEmbedder.String was called
func (f *FakeEmbedder) StringCalled() bool {
	return len(f.StringCalls) != 0
}

// AssertStringCalled calls t.Error if FakeEmbedder.String was not called
func (f *FakeEmbedder) AssertStringCalled(t *testing.T) {
	t.Helper()
	if len(f.StringCalls) == 0 {
		t.Error("FakeEmbedder.String not called, expected at least one")
	}
}

// StringNotCalled returns true if FakeEmbedder.String was not called
func (f *FakeEmbedder) StringNotCalled() bool {
	return len(f.StringCalls) == 0
}

// AssertStringNotCalled calls t.Error if FakeEmbedder.String was called
func (f *FakeEmbedder) AssertStringNotCalled(t *testing.T) {
	t.Helper()
	if len(f.StringCalls) != 0 {
		t.Error("FakeEmbedder.String called, expected none")
	}
}

// StringCalledOnce returns true if FakeEmbedder.String was called exactly once
func (f *FakeEmbedder) StringCalledOnce() bool {
	return len(f.StringCalls) == 1
}

// AssertStringCalledOnce calls t.Error if FakeEmbedder.String was not called exactly once
func (f *FakeEmbedder) AssertStringCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.StringCalls) != 1 {
		t.Errorf("FakeEmbedder.String called %d times, expected 1", len(f.StringCalls))
	}
}

// StringCalledN returns true if FakeEmbedder.String was called at least n times
func (f *FakeEmbedder) StringCalledN(n int) bool {
	return len(f.StringCalls) >= n
}

// AssertStringCalledN calls t.Error if FakeEmbedder.String was called less than n times
func (f *FakeEmbedder) AssertStringCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.StringCalls) < n {
		t.Errorf("FakeEmbedder.String called %d times, expected >= %d", len(f.StringCalls), n)
	}
}

func (_f2 *FakeEmbedder) Embed(ident8 string) (ident9 string) {
	invocation := new(EmbedInvocation)

	invocation.Parameters.Ident8 = ident8

	ident9 = _f2.EmbedHook(ident8)

	invocation.Results.Ident9 = ident9

	_f2.EmbedCalls = append(_f2.EmbedCalls, invocation)

	return
}

// EmbedCalled returns true if FakeEmbedder.Embed was called
func (f *FakeEmbedder) EmbedCalled() bool {
	return len(f.EmbedCalls) != 0
}

// AssertEmbedCalled calls t.Error if FakeEmbedder.Embed was not called
func (f *FakeEmbedder) AssertEmbedCalled(t *testing.T) {
	t.Helper()
	if len(f.EmbedCalls) == 0 {
		t.Error("FakeEmbedder.Embed not called, expected at least one")
	}
}

// EmbedNotCalled returns true if FakeEmbedder.Embed was not called
func (f *FakeEmbedder) EmbedNotCalled() bool {
	return len(f.EmbedCalls) == 0
}

// AssertEmbedNotCalled calls t.Error if FakeEmbedder.Embed was called
func (f *FakeEmbedder) AssertEmbedNotCalled(t *testing.T) {
	t.Helper()
	if len(f.EmbedCalls) != 0 {
		t.Error("FakeEmbedder.Embed called, expected none")
	}
}

// EmbedCalledOnce returns true if FakeEmbedder.Embed was called exactly once
func (f *FakeEmbedder) EmbedCalledOnce() bool {
	return len(f.EmbedCalls) == 1
}

// AssertEmbedCalledOnce calls t.Error if FakeEmbedder.Embed was not called exactly once
func (f *FakeEmbedder) AssertEmbedCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.EmbedCalls) != 1 {
		t.Errorf("FakeEmbedder.Embed called %d times, expected 1", len(f.EmbedCalls))
	}
}

// EmbedCalledN returns true if FakeEmbedder.Embed was called at least n times
func (f *FakeEmbedder) EmbedCalledN(n int) bool {
	return len(f.EmbedCalls) >= n
}

// AssertEmbedCalledN calls t.Error if FakeEmbedder.Embed was called less than n times
func (f *FakeEmbedder) AssertEmbedCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.EmbedCalls) < n {
		t.Errorf("FakeEmbedder.Embed called %d times, expected >= %d", len(f.EmbedCalls), n)
	}
}

// EmbedCalledWith returns true if FakeEmbedder.Embed was called with the given values
func (_f3 *FakeEmbedder) EmbedCalledWith(ident8 string) (found bool) {
	for _, call := range _f3.EmbedCalls {
		if reflect.DeepEqual(call.Parameters.Ident8, ident8) {
			found = true
			break
		}
	}

	return
}

// AssertEmbedCalledWith calls t.Error if FakeEmbedder.Embed was not called with the given values
func (_f4 *FakeEmbedder) AssertEmbedCalledWith(t *testing.T, ident8 string) {
	t.Helper()
	var found bool
	for _, call := range _f4.EmbedCalls {
		if reflect.DeepEqual(call.Parameters.Ident8, ident8) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeEmbedder.Embed not called with expected parameters")
	}
}

// EmbedCalledOnceWith returns true if FakeEmbedder.Embed was called exactly once with the given values
func (_f5 *FakeEmbedder) EmbedCalledOnceWith(ident8 string) bool {
	var count int
	for _, call := range _f5.EmbedCalls {
		if reflect.DeepEqual(call.Parameters.Ident8, ident8) {
			count++
		}
	}

	return count == 1
}

// AssertEmbedCalledOnceWith calls t.Error if FakeEmbedder.Embed was not called exactly once with the given values
func (_f6 *FakeEmbedder) AssertEmbedCalledOnceWith(t *testing.T, ident8 string) {
	t.Helper()
	var count int
	for _, call := range _f6.EmbedCalls {
		if reflect.DeepEqual(call.Parameters.Ident8, ident8) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeEmbedder.Embed called %d times with expected parameters, expected one", count)
	}
}

// EmbedResultsForCall returns the result values for the first call to FakeEmbedder.Embed with the given values
func (_f7 *FakeEmbedder) EmbedResultsForCall(ident8 string) (ident9 string, found bool) {
	for _, call := range _f7.EmbedCalls {
		if reflect.DeepEqual(call.Parameters.Ident8, ident8) {
			ident9 = call.Results.Ident9
			found = true
			break
		}
	}

	return
}

func (_f8 *FakeEmbedder) Other(ident6 string) (ident7 string) {
	invocation := new(OtherInvocation)

	invocation.Parameters.Ident6 = ident6

	ident7 = _f8.OtherHook(ident6)

	invocation.Results.Ident7 = ident7

	_f8.OtherCalls = append(_f8.OtherCalls, invocation)

	return
}

// OtherCalled returns true if FakeEmbedder.Other was called
func (f *FakeEmbedder) OtherCalled() bool {
	return len(f.OtherCalls) != 0
}

// AssertOtherCalled calls t.Error if FakeEmbedder.Other was not called
func (f *FakeEmbedder) AssertOtherCalled(t *testing.T) {
	t.Helper()
	if len(f.OtherCalls) == 0 {
		t.Error("FakeEmbedder.Other not called, expected at least one")
	}
}

// OtherNotCalled returns true if FakeEmbedder.Other was not called
func (f *FakeEmbedder) OtherNotCalled() bool {
	return len(f.OtherCalls) == 0
}

// AssertOtherNotCalled calls t.Error if FakeEmbedder.Other was called
func (f *FakeEmbedder) AssertOtherNotCalled(t *testing.T) {
	t.Helper()
	if len(f.OtherCalls) != 0 {
		t.Error("FakeEmbedder.Other called, expected none")
	}
}

// OtherCalledOnce returns true if FakeEmbedder.Other was called exactly once
func (f *FakeEmbedder) OtherCalledOnce() bool {
	return len(f.OtherCalls) == 1
}

// AssertOtherCalledOnce calls t.Error if FakeEmbedder.Other was not called exactly once
func (f *FakeEmbedder) AssertOtherCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.OtherCalls) != 1 {
		t.Errorf("FakeEmbedder.Other called %d times, expected 1", len(f.OtherCalls))
	}
}

// OtherCalledN returns true if FakeEmbedder.Other was called at least n times
func (f *FakeEmbedder) OtherCalledN(n int) bool {
	return len(f.OtherCalls) >= n
}

// AssertOtherCalledN calls t.Error if FakeEmbedder.Other was called less than n times
func (f *FakeEmbedder) AssertOtherCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.OtherCalls) < n {
		t.Errorf("FakeEmbedder.Other called %d times, expected >= %d", len(f.OtherCalls), n)
	}
}

// OtherCalledWith returns true if FakeEmbedder.Other was called with the given values
func (_f9 *FakeEmbedder) OtherCalledWith(ident6 string) (found bool) {
	for _, call := range _f9.OtherCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) {
			found = true
			break
		}
	}

	return
}

// AssertOtherCalledWith calls t.Error if FakeEmbedder.Other was not called with the given values
func (_f10 *FakeEmbedder) AssertOtherCalledWith(t *testing.T, ident6 string) {
	t.Helper()
	var found bool
	for _, call := range _f10.OtherCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeEmbedder.Other not called with expected parameters")
	}
}

// OtherCalledOnceWith returns true if FakeEmbedder.Other was called exactly once with the given values
func (_f11 *FakeEmbedder) OtherCalledOnceWith(ident6 string) bool {
	var count int
	for _, call := range _f11.OtherCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) {
			count++
		}
	}

	return count == 1
}

// AssertOtherCalledOnceWith calls t.Error if FakeEmbedder.Other was not called exactly once with the given values
func (_f12 *FakeEmbedder) AssertOtherCalledOnceWith(t *testing.T, ident6 string) {
	t.Helper()
	var count int
	for _, call := range _f12.OtherCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeEmbedder.Other called %d times with expected parameters, expected one", count)
	}
}

// OtherResultsForCall returns the result values for the first call to FakeEmbedder.Other with the given values
func (_f13 *FakeEmbedder) OtherResultsForCall(ident6 string) (ident7 string, found bool) {
	for _, call := range _f13.OtherCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) {
			ident7 = call.Results.Ident7
			found = true
			break
		}
	}

	return
}
