// generated by "charlatan -dir=testdata/interfacer -output=testdata/interfacer/interfacer.go Interfacer".  DO NOT EDIT.

package main

import "reflect"

// InterfacerInterfaceInvocation represents a single call of FakeInterfacer.Interface
type InterfacerInterfaceInvocation struct {
	Parameters struct {
		Ident1 interface{}
	}
	Results struct {
		Ident2 interface{}
	}
}

// InterfacerNamedInterfaceInvocation represents a single call of FakeInterfacer.NamedInterface
type InterfacerNamedInterfaceInvocation struct {
	Parameters struct {
		A interface{}
	}
	Results struct {
		Z interface{}
	}
}

// InterfacerTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type InterfacerTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeInterfacer is a mock implementation of Interfacer for testing.
Use it in your tests as in this example:

	package example

	func TestWithInterfacer(t *testing.T) {
		f := &main.FakeInterfacer{
			InterfaceHook: func(ident1 interface{}) (ident2 interface{}) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeInterface ...
		f.AssertInterfaceCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeInterface.
*/
type FakeInterfacer struct {
	InterfaceHook      func(interface{}) interface{}
	NamedInterfaceHook func(interface{}) interface{}

	InterfaceCalls      []*InterfacerInterfaceInvocation
	NamedInterfaceCalls []*InterfacerNamedInterfaceInvocation
}

// NewFakeInterfacerDefaultPanic returns an instance of FakeInterfacer with all hooks configured to panic
func NewFakeInterfacerDefaultPanic() *FakeInterfacer {
	return &FakeInterfacer{
		InterfaceHook: func(interface{}) (ident2 interface{}) {
			panic("Unexpected call to Interfacer.Interface")
		},
		NamedInterfaceHook: func(interface{}) (z interface{}) {
			panic("Unexpected call to Interfacer.NamedInterface")
		},
	}
}

// NewFakeInterfacerDefaultFatal returns an instance of FakeInterfacer with all hooks configured to call t.Fatal
func NewFakeInterfacerDefaultFatal(t InterfacerTestingT) *FakeInterfacer {
	return &FakeInterfacer{
		InterfaceHook: func(interface{}) (ident2 interface{}) {
			t.Fatal("Unexpected call to Interfacer.Interface")
			return
		},
		NamedInterfaceHook: func(interface{}) (z interface{}) {
			t.Fatal("Unexpected call to Interfacer.NamedInterface")
			return
		},
	}
}

// NewFakeInterfacerDefaultError returns an instance of FakeInterfacer with all hooks configured to call t.Error
func NewFakeInterfacerDefaultError(t InterfacerTestingT) *FakeInterfacer {
	return &FakeInterfacer{
		InterfaceHook: func(interface{}) (ident2 interface{}) {
			t.Error("Unexpected call to Interfacer.Interface")
			return
		},
		NamedInterfaceHook: func(interface{}) (z interface{}) {
			t.Error("Unexpected call to Interfacer.NamedInterface")
			return
		},
	}
}

func (f *FakeInterfacer) Reset() {
	f.InterfaceCalls = []*InterfacerInterfaceInvocation{}
	f.NamedInterfaceCalls = []*InterfacerNamedInterfaceInvocation{}
}

func (_f1 *FakeInterfacer) Interface(ident1 interface{}) (ident2 interface{}) {
	if _f1.InterfaceHook == nil {
		panic("Interfacer.Interface() called but FakeInterfacer.InterfaceHook is nil")
	}

	invocation := new(InterfacerInterfaceInvocation)
	_f1.InterfaceCalls = append(_f1.InterfaceCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f1.InterfaceHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// SetInterfaceStub configures Interfacer.Interface to always return the given values
func (_f2 *FakeInterfacer) SetInterfaceStub(ident2 interface{}) {
	_f2.InterfaceHook = func(interface{}) interface{} {
		return ident2
	}
}

// SetInterfaceInvocation configures Interfacer.Interface to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f3 *FakeInterfacer) SetInterfaceInvocation(calls_f4 []*InterfacerInterfaceInvocation, fallback_f5 func() interface{}) {
	_f3.InterfaceHook = func(ident1 interface{}) (ident2 interface{}) {
		for _, call := range calls_f4 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
				ident2 = call.Results.Ident2

				return
			}
		}

		return fallback_f5()
	}
}

// InterfaceCalled returns true if FakeInterfacer.Interface was called
func (f *FakeInterfacer) InterfaceCalled() bool {
	return len(f.InterfaceCalls) != 0
}

// AssertInterfaceCalled calls t.Error if FakeInterfacer.Interface was not called
func (f *FakeInterfacer) AssertInterfaceCalled(t InterfacerTestingT) {
	t.Helper()
	if len(f.InterfaceCalls) == 0 {
		t.Error("FakeInterfacer.Interface not called, expected at least one")
	}
}

// InterfaceNotCalled returns true if FakeInterfacer.Interface was not called
func (f *FakeInterfacer) InterfaceNotCalled() bool {
	return len(f.InterfaceCalls) == 0
}

// AssertInterfaceNotCalled calls t.Error if FakeInterfacer.Interface was called
func (f *FakeInterfacer) AssertInterfaceNotCalled(t InterfacerTestingT) {
	t.Helper()
	if len(f.InterfaceCalls) != 0 {
		t.Error("FakeInterfacer.Interface called, expected none")
	}
}

// InterfaceCalledOnce returns true if FakeInterfacer.Interface was called exactly once
func (f *FakeInterfacer) InterfaceCalledOnce() bool {
	return len(f.InterfaceCalls) == 1
}

// AssertInterfaceCalledOnce calls t.Error if FakeInterfacer.Interface was not called exactly once
func (f *FakeInterfacer) AssertInterfaceCalledOnce(t InterfacerTestingT) {
	t.Helper()
	if len(f.InterfaceCalls) != 1 {
		t.Errorf("FakeInterfacer.Interface called %d times, expected 1", len(f.InterfaceCalls))
	}
}

// InterfaceCalledN returns true if FakeInterfacer.Interface was called at least n times
func (f *FakeInterfacer) InterfaceCalledN(n int) bool {
	return len(f.InterfaceCalls) >= n
}

// AssertInterfaceCalledN calls t.Error if FakeInterfacer.Interface was called less than n times
func (f *FakeInterfacer) AssertInterfaceCalledN(t InterfacerTestingT, n int) {
	t.Helper()
	if len(f.InterfaceCalls) < n {
		t.Errorf("FakeInterfacer.Interface called %d times, expected >= %d", len(f.InterfaceCalls), n)
	}
}

// InterfaceCalledWith returns true if FakeInterfacer.Interface was called with the given values
func (_f6 *FakeInterfacer) InterfaceCalledWith(ident1 interface{}) (found bool) {
	for _, call := range _f6.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertInterfaceCalledWith calls t.Error if FakeInterfacer.Interface was not called with the given values
func (_f7 *FakeInterfacer) AssertInterfaceCalledWith(t InterfacerTestingT, ident1 interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f7.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeInterfacer.Interface not called with expected parameters")
	}
}

// InterfaceCalledOnceWith returns true if FakeInterfacer.Interface was called exactly once with the given values
func (_f8 *FakeInterfacer) InterfaceCalledOnceWith(ident1 interface{}) bool {
	var count int
	for _, call := range _f8.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertInterfaceCalledOnceWith calls t.Error if FakeInterfacer.Interface was not called exactly once with the given values
func (_f9 *FakeInterfacer) AssertInterfaceCalledOnceWith(t InterfacerTestingT, ident1 interface{}) {
	t.Helper()
	var count int
	for _, call := range _f9.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeInterfacer.Interface called %d times with expected parameters, expected one", count)
	}
}

// InterfaceResultsForCall returns the result values for the first call to FakeInterfacer.Interface with the given values
func (_f10 *FakeInterfacer) InterfaceResultsForCall(ident1 interface{}) (ident2 interface{}, found bool) {
	for _, call := range _f10.InterfaceCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f11 *FakeInterfacer) NamedInterface(a interface{}) (z interface{}) {
	if _f11.NamedInterfaceHook == nil {
		panic("Interfacer.NamedInterface() called but FakeInterfacer.NamedInterfaceHook is nil")
	}

	invocation := new(InterfacerNamedInterfaceInvocation)
	_f11.NamedInterfaceCalls = append(_f11.NamedInterfaceCalls, invocation)

	invocation.Parameters.A = a

	z = _f11.NamedInterfaceHook(a)

	invocation.Results.Z = z

	return
}

// SetNamedInterfaceStub configures Interfacer.NamedInterface to always return the given values
func (_f12 *FakeInterfacer) SetNamedInterfaceStub(z interface{}) {
	_f12.NamedInterfaceHook = func(interface{}) interface{} {
		return z
	}
}

// SetNamedInterfaceInvocation configures Interfacer.NamedInterface to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f13 *FakeInterfacer) SetNamedInterfaceInvocation(calls_f14 []*InterfacerNamedInterfaceInvocation, fallback_f15 func() interface{}) {
	_f13.NamedInterfaceHook = func(a interface{}) (z interface{}) {
		for _, call := range calls_f14 {
			if reflect.DeepEqual(call.Parameters.A, a) {
				z = call.Results.Z

				return
			}
		}

		return fallback_f15()
	}
}

// NamedInterfaceCalled returns true if FakeInterfacer.NamedInterface was called
func (f *FakeInterfacer) NamedInterfaceCalled() bool {
	return len(f.NamedInterfaceCalls) != 0
}

// AssertNamedInterfaceCalled calls t.Error if FakeInterfacer.NamedInterface was not called
func (f *FakeInterfacer) AssertNamedInterfaceCalled(t InterfacerTestingT) {
	t.Helper()
	if len(f.NamedInterfaceCalls) == 0 {
		t.Error("FakeInterfacer.NamedInterface not called, expected at least one")
	}
}

// NamedInterfaceNotCalled returns true if FakeInterfacer.NamedInterface was not called
func (f *FakeInterfacer) NamedInterfaceNotCalled() bool {
	return len(f.NamedInterfaceCalls) == 0
}

// AssertNamedInterfaceNotCalled calls t.Error if FakeInterfacer.NamedInterface was called
func (f *FakeInterfacer) AssertNamedInterfaceNotCalled(t InterfacerTestingT) {
	t.Helper()
	if len(f.NamedInterfaceCalls) != 0 {
		t.Error("FakeInterfacer.NamedInterface called, expected none")
	}
}

// NamedInterfaceCalledOnce returns true if FakeInterfacer.NamedInterface was called exactly once
func (f *FakeInterfacer) NamedInterfaceCalledOnce() bool {
	return len(f.NamedInterfaceCalls) == 1
}

// AssertNamedInterfaceCalledOnce calls t.Error if FakeInterfacer.NamedInterface was not called exactly once
func (f *FakeInterfacer) AssertNamedInterfaceCalledOnce(t InterfacerTestingT) {
	t.Helper()
	if len(f.NamedInterfaceCalls) != 1 {
		t.Errorf("FakeInterfacer.NamedInterface called %d times, expected 1", len(f.NamedInterfaceCalls))
	}
}

// NamedInterfaceCalledN returns true if FakeInterfacer.NamedInterface was called at least n times
func (f *FakeInterfacer) NamedInterfaceCalledN(n int) bool {
	return len(f.NamedInterfaceCalls) >= n
}

// AssertNamedInterfaceCalledN calls t.Error if FakeInterfacer.NamedInterface was called less than n times
func (f *FakeInterfacer) AssertNamedInterfaceCalledN(t InterfacerTestingT, n int) {
	t.Helper()
	if len(f.NamedInterfaceCalls) < n {
		t.Errorf("FakeInterfacer.NamedInterface called %d times, expected >= %d", len(f.NamedInterfaceCalls), n)
	}
}

// NamedInterfaceCalledWith returns true if FakeInterfacer.NamedInterface was called with the given values
func (_f16 *FakeInterfacer) NamedInterfaceCalledWith(a interface{}) (found bool) {
	for _, call := range _f16.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			found = true
			break
		}
	}

	return
}

// AssertNamedInterfaceCalledWith calls t.Error if FakeInterfacer.NamedInterface was not called with the given values
func (_f17 *FakeInterfacer) AssertNamedInterfaceCalledWith(t InterfacerTestingT, a interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f17.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeInterfacer.NamedInterface not called with expected parameters")
	}
}

// NamedInterfaceCalledOnceWith returns true if FakeInterfacer.NamedInterface was called exactly once with the given values
func (_f18 *FakeInterfacer) NamedInterfaceCalledOnceWith(a interface{}) bool {
	var count int
	for _, call := range _f18.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			count++
		}
	}

	return count == 1
}

// AssertNamedInterfaceCalledOnceWith calls t.Error if FakeInterfacer.NamedInterface was not called exactly once with the given values
func (_f19 *FakeInterfacer) AssertNamedInterfaceCalledOnceWith(t InterfacerTestingT, a interface{}) {
	t.Helper()
	var count int
	for _, call := range _f19.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeInterfacer.NamedInterface called %d times with expected parameters, expected one", count)
	}
}

// NamedInterfaceResultsForCall returns the result values for the first call to FakeInterfacer.NamedInterface with the given values
func (_f20 *FakeInterfacer) NamedInterfaceResultsForCall(a interface{}) (z interface{}, found bool) {
	for _, call := range _f20.NamedInterfaceCalls {
		if reflect.DeepEqual(call.Parameters.A, a) {
			z = call.Results.Z
			found = true
			break
		}
	}

	return
}
